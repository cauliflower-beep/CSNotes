## 前言

为什么要有`TCP/IP`网络模型?

对于同一台设备上、进程之间的通信，有很多种方式来实现。比如管道、消息队列、共享内存、信号等；而对于不同设备上的进程间通信，就需要网络通信了。

由于设备是多样的，所以要兼容各种设备，就需要协商出一套通用的网络协议。

这个网络协议是分层的，每一层都有各自的作用和职责，接下来就针对`TCP/IP网络模型`的每一层进行介绍。

## 1.TCP/IP分层

### 1.1应用层

首先我们能直接接触到的就是应用层，它位于整个`TCP/IP网络模型`的最上层。我们电脑或手机使用的应用软件都在应用层中实现。当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。

所以，应用层只需要专注于为用户提供应用功能，比如HTTP、FTP、Telnet、DNS、SMTP等。

应用层不用去关心数据是如何传输的，就类似于，我们寄快递的时候，只需要把包裹交给快递员，由他们负责运输快递，我们不需要关系快递具体如何被运输。

应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。

### 1.2传输层

应用层的数据包会传给传输层，传输层（Transport Layer）是为应用层提供网络支持的。

![传输层](\imgs\传输层.png)

在传输层会有两个传输协议，分别是TCP和UDP。

`TCP`全称叫传输控制协议（*Transmission Control Protocol*），大部分应用使用的正是TCP传输层协议，比如HTTP应用层协议。TCP相比UDP多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠的传输给对方。

`UDP`相对来说简单一些，简单到只负责发送数据包，不保证数据包能否抵达对方。但它实时性相对更好，传输效率也更高。当然，UDP也可以实现可靠传输，把TCP的特性在应用层上实现就可以，不过要实现一个商用的可靠的UDP传输协议，并不是一件简单的事情。

如果应用需要传输的数据非常大，直接传输就不好控制。因此当传输的数据包大小超过`MSS`(TCP最大报文长度)，就需要将数据包分块。这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块即可，不用重新发送整个数据包。在TCP协议中，我们把每个分块称为一个`TCP段`（TCP Segment）。

![tcp分段](\imgs\tcp分段.png)

当设备作为接收方时，传输层要负责把数据包传给应用；但是一台设备上可能会有很多应用程序在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是端口。

比如80端口通常是web服务器用的，22端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏，都是一个独立的进程，操作系统会为这些进程分配临时的端口号。

由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。

### 1.3网络层

传输层可能刚接触的时候，会认为它负责将数据从一个设备传输到另一个设备，事实上它并不负责。

实际场景中的网络环节是错综复杂的，中间有各种各样的线路和分岔路口。如果一个设备的数据要传输给另一个设备，就需要在各种各样的节点和路径之间进行选择。如果传输层还负责这一块儿的功能，就有点违背设计原则了，因为传输层的设计理念是简单、高效、专注。

也就是说，我们不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能交给下一层：网络层。

![网络层](\imgs\网络层.png)

网络层最常用的是`IP协议`（*Internet Protocol*），IP协议会将传输层的报文作为数据部分，再加上IP包头组装成IP报文，如果IP报文大小超过`MTU`(以太网中一般为1500字节)就会再次进行分片，得到一个即将发送到网络的IP报文。

![12](\imgs\12.png)

网络层负责将数据从一个设备传输到另一个设备，世界上那么多设备，该如何找到对方呢?为解决这个问题，网络层需要有区分设备的编号。

我们一般用ip地址给设备编号。对于 IPv4协议，IP地址共32位，分成了4段（例如192.168.100.1），每段是8位。只有一个单纯的 IP地址 虽然做到了区分设备，但是寻址起来特别麻烦。全世界那么多台设备，难道一个一个去匹配?这显然不科学。

因此，需要将 IP地址分成两种意义：

- `网络号`—负责标识该IP地址是属于哪个`子网`的；
- `主机号`—负责标识同一`子网`下的不同主机。

怎么分的呢?这需要配合`子网掩码`才能算出IP地址的网络号和主机号。

举个例子，比如 `10.100.122.0/24`，后面的 `/24` 表示 `255.255.255.0` 子网掩码，255.255.255.0 二进制是 [11111111-11111111-11111111-00000000]，没错，正是24个1。为了简化子网掩码的表示，用 /24 代替255.255.255.0。

知道了子网掩码，该怎么计算出网络地址和主机地址呢？

将 10.100.122.2 和 255.255.255.0 进行按位与运算，就可以得到网络号。如下所示：

```go
IP地址：10.100.122.2
	00001010 01100100 01111010 00000010
子网掩码：255.255.255.0
	11111111 11111111 11111111 00000000
// IP地址和子网掩码做AND运算
网络号：10.100.122.0
	00001010 01100100 01111010 00000000
```

将 255.255.255.0 取反后与 IP地址进行按位与运算，就可以得到主机号：

```go
IP地址：10.100.122.2
	00001010 01100100 01111010 00000010
子网掩码：255.255.255.0
	11111111 11111111 11111111 00000000
// 子网掩码取反，再与IP地址做AND运算
取反：0.0.0.255
	00000000 00000000 00000000 11111111
主机号：0.0.0.2
	00000000 00000000 00000000 00000010
```

可以搜索子网掩码计算器，改变`掩码位`的数值，体会子网掩码的作用。

[子网掩码计算器-在线IP地址计算器 (subnet-mask.com)](http://www.subnet-mask.com/)

在寻址过程中，先匹配到相同的网络号（表示要找到同一个子网），才会去找对应的主机。

除了寻址能力，IP协议还有另一个重要的能力就是`路由`。实际场景中，两台设备并不是用同一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。

路由器寻址工作中，就是要找到目标地址的子网，进而把数据包转发给对应的网络内。

![17](\imgs\17.png)

所以，IP协议的寻址作用，是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据下一个目的地选择路径。寻址更像是在导航，路由更像是在操作方向盘。

### 1.4网络接口层

生成了 IP 头部之后，接下来要交给`网络接口层`（*Link Layer*），在 IP 头部的前面加上 mac 头部，并封装成数据帧（Data frame）发送到网络上。

![网络接口层](\imgs\网络接口层.png)

IP 头部中的接收方 IP地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，这个思路是行不通的。

什么是以太网呢?

>  电脑上的以太网接口、wifi接口、以太网交换机、路由器上的千兆、万兆以太网口，还有网线，他们都是以太网的组成部分。以太网就是在一种`局域网`内，把附近的设备连接起来，是他们之间可以进行通信的技术。

以太网在判断网络包目的地址时和IP的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而mac头部就是干这个用的。所以，在以太网进行通讯要用到mac地址。

mac头部是以太网使用的头部，它包含了接收方和发送方的mac地址等信息，我们可以通过ARP协议获取对方的mac地址。

所以说，网络接口层主要是为网络层提供`链路级别`传输的服务，负责在以太网、wifi这样的底层网络上发送原始数据包，工作在网卡这个层次，使用mac地址来标识网络上的设备。

### 1.5总结

综上所述，TCP/IP 网络通常是由上到下分成4层，分别是`应用层`、`传输层`、`网络层`和`网络接口层`。

![分层总结](\imgs\分层总结.png)

每一层的封装格式如下：

![封装](\imgs\封装.png)

网络接口层的传输单位是帧（frame），ip层的传输单位是包（packet），tcp层的传输单位是段(segment)，http的传输单位是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。

## 2.键入网址之后的故事

学习计算机网络的过程中，总会主动或者被动的面对一个问题：

>  当键入网址后，到网页显示，期间发生了什么？

下面我们从一个简单的网络拓扑模型开始，研究一下期间到底发生了什么：

![网络拓扑模型](\imgs\网络拓扑模型.png)

### 2.1 孤单小弟——HTTP

> 浏览器做的第一步工作是解析 URL

首先浏览器做的第一步工作就是要对 URL 进行解析，从而生成请求信息，发送给web服务器。

来看看一条长长的 URL 中的各个元素代表什么：

![URL解析](\imgs\URL解析.png)

所以图中长长的 URL 实际上是请求服务器里的文件资源。

> 要是上图中的蓝色部分 URL 元素都省略了，那应该是请求哪个文件呢?

当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是 `/index.html` 或者`/default.html`这些文件，这样就不会发生混乱了。

> 生产 HTTP 请求信息

对 URL 解析之后，浏览器确定了Web服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。

![http请求消息](\imgs\http请求消息.png)

> 一个孤单的 HTTP 数据包表示：我这么一个小小的数据包，无亲无故，直接发送到浩瀚的网络，谁会知道我呢？谁会载我一程呢?谁能保护我呢?我的目的地在哪呢?
>
> 充满各种疑问的它，没有停滞不前，依然踏上了征途！

### 2.2 真实地址查询——DNS

通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统，将消息发送给 Web 服务器。

但在发送之前，还有一项工作需要完成：查询服务器域名对应的 IP 地址。`因为委托操作系统发送消息时，必须提供通信对象的 IP 地址`。

比如我们打电话的时候，必须要知道对方的电话号码，但由于电话号码难以记忆，所以通常我们会将对方电话号 + 姓名 保存在通讯录里。

所以，有一种服务器专门保存了 web 服务器域名与 ip 的对应关系，他就是 dns 服务器。

> 域名的层级关系

dns 中的域名都是用句点来分割的，比如 `www.baidu.com`，这里的句点代表了不同层次之间的界限。

在域名中，`越靠右`的位置表示其`层级越高`。

毕竟域名是外国人发明的，思维与中国人相反。比如说一个城市地点的时候，外国喜欢从小到大的顺序说起（xx街道xx区xx市xx省），而中国喜欢从大到小的顺序（xx省xx市xx区xx街道）。

实际上域名最后还有一个点，比如`www.baidu.com.`，最后这个点代表根域名。

所以域名的层级关系类似一个树状结构：

- 根 DNS 服务器（`.`）
- 顶级域 DNS 服务器（`.com`）
- 权威 DNS 服务器（`server.com`）

![域名层级关系树状图](\imgs\域名层级关系树状图.png)

根域的DNS服务器信息保存在互联网中所有的DNS服务器中。

这样一来，任何DNS服务器就都可以找到并访问根域DNS服务器了。

因此，客户端只要能够找到任意一台DNS服务器，就可以通过它找到根域DNS服务器，然后再一路顺藤摸瓜找到位于下层的某台目标DNS服务器。

> 域名解析的工作流程

1. 客户端首先会发出一个DNS请求，问 `www.baidu.com`的 IP是啥，并发给本地 DNS服务器，也就是客户端的TCP/IP设置中填写的DNS服务器地址；
2. 本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 `www.baidu.com`，则它直接返回IP地址。如果没有，本地DNS会去问它的根域名服务器：boss，能告诉我 `www.baidu.com`的IP地址吗？根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路；
3. 根DNS收到来自本地DNS的请求后，发现后置是`.com`，说，`www.baidu.com`这个域名归`.com`区域管理，我给你`.com`顶级域名服务器的地址，你去问它；
4. 本地DNS收到顶级域名服务器的地址后，发起请求：sir，能告诉我 `www.baidu.com`的IP地址吗？
5. 顶级域名服务器说，我给你负责`www.baidu.com`区域的权威DNS服务器的地址，你去问它；
6. 本地DNS于是转向问权威DNS服务器，brother，`www.baidu.com`对应的ip是啥？`baidu.com`的权威DNS服务器，它是域名解析结果的原出处。为啥叫权威呢？因为我的域名我做主。
7. 权威DNS服务器查询后，将对应的 IP 地址 `x.x.x.x`告诉本地DNS；
8. 本地DNS再将IP地址返回给客户端，客户端和目标建立连接。

至此，整个DNS的解析过程就完成了：

![dns解析](\imgs\dns解析.png)

DNS 域名解析的过程蛮有意思的，整个过程和日常生活中找人问路的过程类似，只指路不带路。

> 是不是每次解析域名都要经过那么多步骤呢？

当然不是，还有缓存来帮我们提高解析效率。

浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回；如果没有，就去问操作系统。

操作系统也会去看自己的缓存，如果有，就直接返回；如果没有，再去hosts文件看；还没有，才会去问`本地DNS服务器`。

> 数据包表示：DNS老大哥厉害的，找到了目的地了！可我还是很迷茫呀，我要发出去，接下来我需要谁的帮助呢？

### 2.3 指南好帮手——协议栈

通过DNS(应用层协议)获取到IP之后，可以把HTTP的传输工作交给操作系统中的协议栈。

协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定规则的。上面的部分会向下面的部分委托工作，下面的部分收到委托工作并执行。

![7](\imgs\7.png)

应用程序（浏览器）通过调用Socket库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的TCP和UDP协议，这两个传输协议会接受应用层的委托，执行收发数据的操作。

协议栈的下面一半是用IP协议控制网络包收发操作，在互联网上传数据时，数据会被切成一块块的网络包，而将网络包发送给对方的操作就是由IP负责的。

此外IP中还包括`ICMP`协议和`ARP`协议：

- `ICMP`用于告知网络包传送过程中产生的错误以及各种控制信息。
- `ARP`用于根据IP地址查询相应的以太网MAC地址。

IP下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。

> 数据包看了这份指南表示：原来我需要那么多大佬的协助啊！那我先去找找TCP大佬！

### 2.4 可靠传输——TCP

HTTP是基于TCP协议传输的，所以我们先了解一下TCP协议。

#### 2.4.1TCP报文头部

![8](\imgs\8.png)

首先，`源端口号`和`目标端口`是必不可少的。如果没有这两个端口号，数据就不知道应该发送给哪个应用。

接下来是包的`序号`，这个是为了解决包乱序的问题。

然后是应该有的`确认号`，目的是确认发出去的包，对方是否有收到。如果没有就应该重新发送，直至送达。这个是为了解决丢包的问题。

接着还有一些状态位，例如`SYN`是发起一个链接，`ACK`是回复，`RST`是重新连接，`FIN`是结束连接等。TCP是面向连接的，因而双方要维护连接的状态。这些带状态位的包的发送，会引起双方的状态变更。

还有一个重要的内容是`窗口大小`。TCP要做`流量控制`，通信双方各自声明一个窗口（缓存大小），标识当前自己能够处理的能力，别发送的太快，消化不了，也别发的太慢，等的饿肚子。

除了做流量控制外，TCP还会做`拥塞控制`，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度——不能改变世界，那就改变自己。

#### 2.4.2TCP三次握手

在HTTP传输数据之前，需要先建立连接，这个过程通常称为`三次握手`。

所谓“连接”，只是双方计算机里维护一个状态机，在连接建立的过程中，双方的状态变化时序图如下：

![](\imgs\TCP三次握手.png)

过程解析：

- 一开始，客户端和服务端都处于`CLOSE`状态。首先是服务端主动监听某个端口，出与`LISTEN`状态；
- 然后客户端主动发起连接 `SYN`，之后处于 `SYN-SENT` 状态。
- 服务端收到发起的连接，返回 `SYN`，并且 `ACK` 客户端的 `SYN`，之后处于 `SYN-RCVD` 状态。
- 客户端收到服务端发送的 `SYN` 和 `ACK` 之后，发送对 `SYN` 确认的 `ACK`，之后处于 `ESTABLISHED` 状态，因为它一发一收成功了。
- 服务端收到 `ACK` 的 `ACK` 之后，处于 `ESTABLISHED` 状态，因为它也一发一收了。

所以三次握手的目的是`保证双方都有发送和接收的能力`

#### 2.4.3如何查看TCP的连接状态？

TCP的连接状态查看，在`Linux`可以通过 `netstat -napt`命令查看。

![10](\imgs\10.png)

#### 2.4.4TCP分割数据

如果 HTTP 请求消息比较长，超过了 `MSS` 的长度，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。

![11](\imgs\11.png)

- `MTU`：一个网络包的最大长度，以太网中一般为 `1500` 字节。
- `MSS`：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。

数据会被以 `MSS` 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。

![12](\imgs\12.png)

#### 2.4.5TCP报文生成

TCP 协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（HTTP 默认端口号是 `80`， HTTPS 默认端口号是 `443`）。

在双方建立了连接后，TCP 报文中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报文之后，就需交给下面的网络层处理。

至此，网络包的报文如下图：

![13](\imgs\13.png)

> 此时，遇上了 TCP 的 数据包激动表示：太好了，碰到了可靠传输的 TCP 传输，它给我加上 TCP 头部，我不再孤单了，安全感十足啊！有大佬可以保护我的可靠送达！但我应该往哪走呢?

### 2.5 远程定位——IP

### 2.6 两点传输——MAC

### 2.7 出口——网卡

### 2.8 送别者——交换机

### 2.9 出境大门——路由器

### 2.10 互相扒皮——服务器与客户端

### 2.11 一个数据包的感受

## 3.linux系统是如何收发网络包的？

