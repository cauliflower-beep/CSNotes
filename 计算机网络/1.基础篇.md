## 前言

为什么要有`TCP/IP`网络模型?

对于同一台设备上、进程之间的通信，有很多种方式来实现。比如管道、消息队列、共享内存、信号等；而对于不同设备上的进程间通信，就需要网络通信了。

由于设备是多样的，所以要兼容各种设备，就需要协商出一套通用的网络协议。

这个网络协议是分层的，每一层都有各自的作用和职责，接下来就针对`TCP/IP网络模型`的每一层进行介绍。

## 1.TCP/IP分层

### 1.1应用层

首先我们能直接接触到的就是应用层，它位于整个`TCP/IP网络模型`的最上层。我们电脑或手机使用的应用软件都在应用层中实现。当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。

所以，应用层只需要专注于为用户提供应用功能，比如HTTP、FTP、Telnet、DNS、SMTP等。

应用层不用去关心数据是如何传输的，就类似于，我们寄快递的时候，只需要把包裹交给快递员，由他们负责运输快递，我们不需要关系快递具体如何被运输。

应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。

### 1.2传输层

应用层的数据包会传给传输层，传输层（Transport Layer）是为应用层提供网络支持的。

![传输层](\imgs\传输层.png)

在传输层会有两个传输协议，分别是TCP和UDP。

`TCP`全称叫传输控制协议（*Transmission Control Protocol*），大部分应用使用的正是TCP传输层协议，比如HTTP应用层协议。TCP相比UDP多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠的传输给对方。

`UDP`相对来说简单一些，简单到只负责发送数据包，不保证数据包能否抵达对方。但它实时性相对更好，传输效率也更高。当然，UDP也可以实现可靠传输，把TCP的特性在应用层上实现就可以，不过要实现一个商用的可靠的UDP传输协议，并不是一件简单的事情。

如果应用需要传输的数据非常大，直接传输就不好控制。因此当传输的数据包大小超过`MSS`(TCP最大报文长度)，就需要将数据包分块。这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块即可，不用重新发送整个数据包。在TCP协议中，我们把每个分块称为一个`TCP段`（TCP Segment）。

![tcp分段](\imgs\tcp分段.png)

当设备作为接收方时，传输层要负责把数据包传给应用；但是一台设备上可能会有很多应用程序在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是端口。

比如80端口通常是web服务器用的，22端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏，都是一个独立的进程，操作系统会为这些进程分配临时的端口号。

由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。

### 1.3网络层

传输层可能刚接触的时候，会认为它负责将数据从一个设备传输到另一个设备，事实上它并不负责。

实际场景中的网络环节是错综复杂的，中间有各种各样的线路和分岔路口。如果一个设备的数据要传输给另一个设备，就需要在各种各样的节点和路径之间进行选择。如果传输层还负责这一块儿的功能，就有点违背设计原则了，因为传输层的设计理念是简单、高效、专注。

也就是说，我们不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能交给下一层：网络层。

![网络层](\imgs\网络层.png)

网络层最常用的是`IP协议`（*Internet Protocol*），IP协议会将传输层的报文作为数据部分，再加上IP包头组装成IP报文，如果IP报文大小超过`MTU`(以太网中一般为1500字节)就会再次进行分片，得到一个即将发送到网络的IP报文。

![12](\imgs\12.png)

网络层负责将数据从一个设备传输到另一个设备，世界上那么多设备，该如何找到对方呢?为解决这个问题，网络层需要有区分设备的编号。

我们一般用ip地址给设备编号。对于 IPv4协议，IP地址共32位，分成了4段（例如192.168.100.1），每段是8位。只有一个单纯的 IP地址 虽然做到了区分设备，但是寻址起来特别麻烦。全世界那么多台设备，难道一个一个去匹配?这显然不科学。

因此，需要将 IP地址分成两种意义：

- `网络号`—负责标识该IP地址是属于哪个`子网`的；
- `主机号`—负责标识同一`子网`下的不同主机。

怎么分的呢?这需要配合`子网掩码`才能算出IP地址的网络号和主机号。

举个例子，比如 `10.100.122.0/24`，后面的 `/24` 表示 `255.255.255.0` 子网掩码，255.255.255.0 二进制是 [11111111-11111111-11111111-00000000]，没错，正是24个1。为了简化子网掩码的表示，用 /24 代替255.255.255.0。

知道了子网掩码，该怎么计算出网络地址和主机地址呢？

将 10.100.122.2 和 255.255.255.0 进行按位与运算，就可以得到网络号。如下所示：

```go
IP地址：10.100.122.2
	00001010 01100100 01111010 00000010
子网掩码：255.255.255.0
	11111111 11111111 11111111 00000000
// IP地址和子网掩码做AND运算
网络号：10.100.122.0
	00001010 01100100 01111010 00000000
```

将 255.255.255.0 取反后与 IP地址进行按位与运算，就可以得到主机号：

```go
IP地址：10.100.122.2
	00001010 01100100 01111010 00000010
子网掩码：255.255.255.0
	11111111 11111111 11111111 00000000
// 子网掩码取反，再与IP地址做AND运算
取反：0.0.0.255
	00000000 00000000 00000000 11111111
主机号：0.0.0.2
	00000000 00000000 00000000 00000010
```

可以搜索子网掩码计算器，改变`掩码位`的数值，体会子网掩码的作用。

[子网掩码计算器-在线IP地址计算器 (subnet-mask.com)](http://www.subnet-mask.com/)

在寻址过程中，先匹配到相同的网络号（表示要找到同一个子网），才会去找对应的主机。

除了寻址能力，IP协议还有另一个重要的能力就是`路由`。实际场景中，两台设备并不是用同一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。

路由器寻址工作中，就是要找到目标地址的子网，进而把数据包转发给对应的网络内。

![17](E:\workspace\src\lsx_notes\计算机网络\1.网络基础篇\imgs\17.png)

所以，IP协议的寻址作用，是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据下一个目的地选择路径。寻址更像是在导航，路由更像是在操作方向盘。

### 1.4网络接口层

生成了 IP 头部之后，接下来要交给`网络接口层`（*Link Layer*），在 IP 头部的前面加上 mac 头部，并封装成数据帧（Data frame）发送到网络上。

![网络接口层](\imgs\网络接口层.png)

IP 头部中的接收方 IP地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，这个思路是行不通的。

什么是以太网呢?

>  电脑上的以太网接口、wifi接口、以太网交换机、路由器上的千兆、万兆以太网口，还有网线，他们都是以太网的组成部分。以太网就是在一种`局域网`内，把附近的设备连接起来，是他们之间可以进行通信的技术。

以太网在判断网络包目的地址时和IP的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而mac头部就是干这个用的。所以，在以太网进行通讯要用到mac地址。

mac头部是以太网使用的头部，它包含了接收方和发送方的mac地址等信息，我们可以通过ARP协议获取对方的mac地址。

所以说，网络接口层主要是为网络层提供`链路级别`传输的服务，负责在以太网、wifi这样的底层网络上发送原始数据包，工作在网卡这个层次，使用mac地址来标识网络上的设备。

### 1.5总结

综上所述，TCP/IP 网络通常是由上到下分成4层，分别是`应用层`、`传输层`、`网络层`和`网络接口层`。

![分层总结](\imgs\分层总结.png)

每一层的封装格式如下：

![封装](\imgs\封装.png)

网络接口层的传输单位是帧（frame），ip层的传输单位是包（packet），tcp层的传输单位是段(segment)，http的传输单位是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。

## 2.键入网址之后的故事

## 3.linux系统是如何收发网络包的？

