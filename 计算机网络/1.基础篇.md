## 前言

为什么要有`TCP/IP`网络模型?

对于同一台设备上、进程之间的通信，有很多种方式来实现。比如管道、消息队列、共享内存、信号等；而对于不同设备上的进程间通信，就需要网络通信了。

由于设备是多样的，所以要兼容各种设备，就需要协商出一套通用的网络协议。

这个网络协议是分层的，每一层都有各自的作用和职责，接下来就针对`TCP/IP网络模型`的每一层进行介绍。

## 1.TCP/IP分层

### 1.1应用层

首先我们能直接接触到的就是应用层，它位于整个`TCP/IP网络模型`的最上层。我们电脑或手机使用的应用软件都在应用层中实现。当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。

所以，应用层只需要专注于为用户提供应用功能，比如HTTP、FTP、Telnet、DNS、SMTP等。

应用层不用去关心数据是如何传输的，就类似于，我们寄快递的时候，只需要把包裹交给快递员，由他们负责运输快递，我们不需要关系快递具体如何被运输。

应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。

### 1.2传输层

应用层的数据包会传给传输层，传输层（Transport Layer）是为应用层提供网络支持的。

![传输层](\imgs\传输层.png)

在传输层会有两个传输协议，分别是TCP和UDP。

`TCP`全称叫传输控制协议（*Transmission Control Protocol*），大部分应用使用的正是TCP传输层协议，比如HTTP应用层协议。TCP相比UDP多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠的传输给对方。

`UDP`相对来说简单一些，简单到只负责发送数据包，不保证数据包能否抵达对方。但它实时性相对更好，传输效率也更高。当然，UDP也可以实现可靠传输，把TCP的特性在应用层上实现就可以，不过要实现一个商用的可靠的UDP传输协议，并不是一件简单的事情。

如果应用需要传输的数据非常大，直接传输就不好控制。因此当传输的数据包大小超过`MSS`(TCP最大报文长度)，就需要将数据包分块。这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块即可，不用重新发送整个数据包。在TCP协议中，我们把每个分块称为一个`TCP段`（TCP Segment）。

![tcp分段](\imgs\tcp分段.png)

当设备作为接收方时，传输层要负责把数据包传给应用；但是一台设备上可能会有很多应用程序在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是端口。

比如80端口通常是web服务器用的，22端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏，都是一个独立的进程，操作系统会为这些进程分配临时的端口号。

由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。

### 1.3网络层

传输层可能刚接触的时候，会认为它负责将数据从一个设备传输到另一个设备，事实上它并不负责。

实际场景中的网络环节是错综复杂的，中间有各种各样的线路和分岔路口。如果一个设备的数据要传输给另一个设备，就需要在各种各样的节点和路径之间进行选择。如果传输层还负责这一块儿的功能，就有点违背设计原则了，因为传输层的设计理念是简单、高效、专注。

也就是说，我们不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能交给下一层：网络层。

![网络层](\imgs\网络层.png)

网络层最常用的是`IP协议`（*Internet Protocol*），IP协议会将传输层的报文作为数据部分，再加上IP包头组装成IP报文，如果IP报文大小超过`MTU`(以太网中一般为1500字节)就会再次进行分片，得到一个即将发送到网络的IP报文。

![12](\imgs\12.png)

网络层负责将数据从一个设备传输到另一个设备，世界上那么多设备，该如何找到对方呢?为解决这个问题，网络层需要有区分设备的编号。

我们一般用ip地址给设备编号。对于 IPv4协议，IP地址共32位，分成了4段（例如192.168.100.1），每段是8位。只有一个单纯的 IP地址 虽然做到了区分设备，但是寻址起来特别麻烦。全世界那么多台设备，难道一个一个去匹配?这显然不科学。

因此，需要将 IP地址分成两种意义：

- `网络号`—负责标识该IP地址是属于哪个`子网`的；
- `主机号`—负责标识同一`子网`下的不同主机。

怎么分的呢?这需要配合`子网掩码`才能算出IP地址的网络号和主机号。

举个例子，比如 `10.100.122.0/24`，后面的 `/24` 表示 `255.255.255.0` 子网掩码，255.255.255.0 二进制是 [11111111-11111111-11111111-00000000]，没错，正是24个1。为了简化子网掩码的表示，用 /24 代替255.255.255.0。

知道了子网掩码，该怎么计算出网络地址和主机地址呢？

将 10.100.122.2 和 255.255.255.0 进行按位与运算，就可以得到网络号。如下所示：

```go
IP地址：10.100.122.2
	00001010 01100100 01111010 00000010
子网掩码：255.255.255.0
	11111111 11111111 11111111 00000000
// IP地址和子网掩码做AND运算
网络号：10.100.122.0
	00001010 01100100 01111010 00000000
```

将 255.255.255.0 取反后与 IP地址进行按位与运算，就可以得到主机号：

```go
IP地址：10.100.122.2
	00001010 01100100 01111010 00000010
子网掩码：255.255.255.0
	11111111 11111111 11111111 00000000
// 子网掩码取反，再与IP地址做AND运算
取反：0.0.0.255
	00000000 00000000 00000000 11111111
主机号：0.0.0.2
	00000000 00000000 00000000 00000010
```

可以搜索子网掩码计算器，改变`掩码位`的数值，体会子网掩码的作用。

[子网掩码计算器-在线IP地址计算器 (subnet-mask.com)](http://www.subnet-mask.com/)

在寻址过程中，先匹配到相同的网络号（表示要找到同一个子网），才会去找对应的主机。

除了寻址能力，IP协议还有另一个重要的能力就是`路由`。实际场景中，两台设备并不是用同一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。

路由器寻址工作中，就是要找到目标地址的子网，进而把数据包转发给对应的网络内。

![17](\imgs\17.png)

所以，IP协议的寻址作用，是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据下一个目的地选择路径。寻址更像是在导航，路由更像是在操作方向盘。

### 1.4网络接口层

生成了 IP 头部之后，接下来要交给`网络接口层`（*Link Layer*），在 IP 头部的前面加上 mac 头部，并封装成数据帧（Data frame）发送到网络上。

![网络接口层](\imgs\网络接口层.png)

IP 头部中的接收方 IP地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，这个思路是行不通的。

什么是以太网呢?

>  电脑上的以太网接口、wifi接口、以太网交换机、路由器上的千兆、万兆以太网口，还有网线，他们都是以太网的组成部分。以太网就是在一种`局域网`内，把附近的设备连接起来，是他们之间可以进行通信的技术。

以太网在判断网络包目的地址时和IP的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而mac头部就是干这个用的。所以，在以太网进行通讯要用到mac地址。

mac头部是以太网使用的头部，它包含了接收方和发送方的mac地址等信息，我们可以通过ARP协议获取对方的mac地址。

所以说，网络接口层主要是为网络层提供`链路级别`传输的服务，负责在以太网、wifi这样的底层网络上发送原始数据包，工作在网卡这个层次，使用mac地址来标识网络上的设备。

### 1.5总结

综上所述，TCP/IP 网络通常是由上到下分成4层，分别是`应用层`、`传输层`、`网络层`和`网络接口层`。

![分层总结](\imgs\分层总结.png)

每一层的封装格式如下：

![封装](\imgs\封装.png)

网络接口层的传输单位是帧（frame），ip层的传输单位是包（packet），tcp层的传输单位是段(segment)，http的传输单位是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。

## 2.键入网址之后的故事

学习计算机网络的过程中，总会主动或者被动的面对一个问题：

>  当键入网址后，到网页显示，期间发生了什么？

下面我们从一个简单的网络拓扑模型开始，研究一下期间到底发生了什么：

![网络拓扑模型](\imgs\网络拓扑模型.png)

### 2.1 孤单小弟——HTTP

> 浏览器做的第一步工作是解析 URL

首先浏览器做的第一步工作就是要对 URL 进行解析，从而生成请求信息，发送给web服务器。

来看看一条长长的 URL 中的各个元素代表什么：

![URL解析](\imgs\URL解析.png)

所以图中长长的 URL 实际上是请求服务器里的文件资源。

> 要是上图中的蓝色部分 URL 元素都省略了，那应该是请求哪个文件呢?

当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是 `/index.html` 或者`/default.html`这些文件，这样就不会发生混乱了。

> 生产 HTTP 请求信息

对 URL 解析之后，浏览器确定了Web服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。

![http请求消息](\imgs\http请求消息.png)

> 一个孤单的 HTTP 数据包表示：我这么一个小小的数据包，无亲无故，直接发送到浩瀚的网络，谁会知道我呢？谁会载我一程呢?谁能保护我呢?我的目的地在哪呢?
>
> 充满各种疑问的它，没有停滞不前，依然踏上了征途！

### 2.2 真实地址查询——DNS

通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统，将消息发送给 Web 服务器。

但在发送之前，还有一项工作需要完成：查询服务器域名对应的 IP 地址。`因为委托操作系统发送消息时，必须提供通信对象的 IP 地址`。

比如我们打电话的时候，必须要知道对方的电话号码，但由于电话号码难以记忆，所以通常我们会将对方电话号 + 姓名 保存在通讯录里。

所以，有一种服务器专门保存了 web 服务器域名与 ip 的对应关系，他就是 dns 服务器。

> 域名的层级关系

dns 中的域名都是用句点来分割的，比如 `www.baidu.com`，这里的句点代表了不同层次之间的界限。

在域名中，`越靠右`的位置表示其`层级越高`。

毕竟域名是外国人发明的，思维与中国人相反。比如说一个城市地点的时候，外国喜欢从小到大的顺序说起（xx街道xx区xx市xx省），而中国喜欢从大到小的顺序（xx省xx市xx区xx街道）。

实际上域名最后还有一个点，比如`www.baidu.com.`，最后这个点代表根域名。

所以域名的层级关系类似一个树状结构：

- 根 DNS 服务器（`.`）
- 顶级域 DNS 服务器（`.com`）
- 权威 DNS 服务器（`server.com`）

![域名层级关系树状图](\imgs\域名层级关系树状图.png)

根域的DNS服务器信息保存在互联网中所有的DNS服务器中。

这样一来，任何DNS服务器就都可以找到并访问根域DNS服务器了。

因此，客户端只要能够找到任意一台DNS服务器，就可以通过它找到根域DNS服务器，然后再一路顺藤摸瓜找到位于下层的某台目标DNS服务器。

> 域名解析的工作流程

1. 客户端首先会发出一个DNS请求，问 `www.baidu.com`的 IP是啥，并发给本地 DNS服务器，也就是客户端的TCP/IP设置中填写的DNS服务器地址；
2. 本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 `www.baidu.com`，则它直接返回IP地址。如果没有，本地DNS会去问它的根域名服务器：boss，能告诉我 `www.baidu.com`的IP地址吗？根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路；
3. 根DNS收到来自本地DNS的请求后，发现后置是`.com`，说，`www.baidu.com`这个域名归`.com`区域管理，我给你`.com`顶级域名服务器的地址，你去问它；
4. 本地DNS收到顶级域名服务器的地址后，发起请求：sir，能告诉我 `www.baidu.com`的IP地址吗？
5. 顶级域名服务器说，我给你负责`www.baidu.com`区域的权威DNS服务器的地址，你去问它；
6. 本地DNS于是转向问权威DNS服务器，brother，`www.baidu.com`对应的ip是啥？`baidu.com`的权威DNS服务器，它是域名解析结果的原出处。为啥叫权威呢？因为我的域名我做主。
7. 权威DNS服务器查询后，将对应的 IP 地址 `x.x.x.x`告诉本地DNS；
8. 本地DNS再将IP地址返回给客户端，客户端和目标建立连接。

至此，整个DNS的解析过程就完成了：

![dns解析](\imgs\dns解析.png)

DNS 域名解析的过程蛮有意思的，整个过程和日常生活中找人问路的过程类似，只指路不带路。

> 是不是每次解析域名都要经过那么多步骤呢？

当然不是，还有缓存来帮我们提高解析效率。

浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回；如果没有，就去问操作系统。

操作系统也会去看自己的缓存，如果有，就直接返回；如果没有，再去hosts文件看；还没有，才会去问`本地DNS服务器`。

> 数据包表示：DNS老大哥厉害的，找到了目的地了！可我还是很迷茫呀，我要发出去，接下来我需要谁的帮助呢？

### 2.3 指南好帮手——协议栈

通过DNS(应用层协议)获取到IP之后，可以把HTTP的传输工作交给操作系统中的协议栈。

协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定规则的。上面的部分会向下面的部分委托工作，下面的部分收到委托工作并执行。

![7](\imgs\7.png)

应用程序（浏览器）通过调用Socket库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的TCP和UDP协议，这两个传输协议会接受应用层的委托，执行收发数据的操作。

协议栈的下面一半是用IP协议控制网络包收发操作，在互联网上传数据时，数据会被切成一块块的网络包，而将网络包发送给对方的操作就是由IP负责的。

此外IP中还包括`ICMP`协议和`ARP`协议：

- `ICMP`用于告知网络包传送过程中产生的错误以及各种控制信息。
- `ARP`用于根据IP地址查询相应的以太网MAC地址。

IP下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。

> 数据包看了这份指南表示：原来我需要那么多大佬的协助啊！那我先去找找TCP大佬！

### 2.4 可靠传输——TCP

HTTP是基于TCP协议传输的，所以我们先了解一下TCP协议。

#### 2.4.1TCP报文头部

![8](\imgs\8.png)

首先，`源端口号`和`目标端口`是必不可少的。如果没有这两个端口号，数据就不知道应该发送给哪个应用。

接下来是包的`序号`，这个是为了解决包乱序的问题。

然后是应该有的`确认号`，目的是确认发出去的包，对方是否有收到。如果没有就应该重新发送，直至送达。这个是为了解决丢包的问题。

接着还有一些状态位，例如`SYN`是发起一个链接，`ACK`是回复，`RST`是重新连接，`FIN`是结束连接等。TCP是面向连接的，因而双方要维护连接的状态。这些带状态位的包的发送，会引起双方的状态变更。

还有一个重要的内容是`窗口大小`。TCP要做`流量控制`，通信双方各自声明一个窗口（缓存大小），标识当前自己能够处理的能力，别发送的太快，消化不了，也别发的太慢，等的饿肚子。

除了做流量控制外，TCP还会做`拥塞控制`，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度——不能改变世界，那就改变自己。

#### 2.4.2TCP三次握手

在HTTP传输数据之前，需要先建立连接，这个过程通常称为`三次握手`。

所谓“连接”，只是双方计算机里维护一个状态机，在连接建立的过程中，双方的状态变化时序图如下：

![](\imgs\TCP三次握手.png)

过程解析：

- 一开始，客户端和服务端都处于`CLOSE`状态。首先是服务端主动监听某个端口，出与`LISTEN`状态；
- 然后客户端主动发起连接 `SYN`，之后处于 `SYN-SENT` 状态。
- 服务端收到发起的连接，返回 `SYN`，并且 `ACK` 客户端的 `SYN`，之后处于 `SYN-RCVD` 状态。
- 客户端收到服务端发送的 `SYN` 和 `ACK` 之后，发送对 `SYN` 确认的 `ACK`，之后处于 `ESTABLISHED` 状态，因为它一发一收成功了。
- 服务端收到 `ACK` 的 `ACK` 之后，处于 `ESTABLISHED` 状态，因为它也一发一收了。

所以三次握手的目的是`保证双方都有发送和接收的能力`

#### 2.4.3如何查看TCP的连接状态？

TCP的连接状态查看，在`Linux`可以通过 `netstat -napt`命令查看。

![10](\imgs\10.png)

#### 2.4.4TCP分割数据

如果 HTTP 请求消息比较长，超过了 `MSS` 的长度，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。

![11](\imgs\11.png)

- `MTU`：一个网络包的最大长度，以太网中一般为 `1500` 字节。
- `MSS`：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。

数据会被以 `MSS` 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。

![12](\imgs\12.png)

#### 2.4.5TCP报文生成

TCP 协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（HTTP 默认端口号是 `80`， HTTPS 默认端口号是 `443`）。

在双方建立了连接后，TCP 报文中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报文之后，就需交给下面的网络层处理。

至此，网络包的报文如下图：

![13](\imgs\13.png)

> 此时，遇上了 TCP 的 数据包激动表示：太好了，碰到了可靠传输的 TCP 传输，它给我加上 TCP 头部，我不再孤单了，安全感十足啊！有大佬可以保护我的可靠送达！但我应该往哪走呢?

### 2.5 远程定位——IP

TCP模块在执行连接、收发、断开等各阶段操作时，都需要委托IP模块将数据封装成`网络包`发送给通信对象。

>  IP包头格式

先来看看IP报文头部的格式：

![14](\imgs\14.png)

在IP协议里面需要有`源地址IP`和`目标地址IP`：

- 源地址IP，即是客户端输出的IP地址；
- 目标地址，即是通过DNS域名解析得到的Web服务器IP。

因为HTTP是经过TCP传输的，所以IP包头的协议号，要填写为`06(十六进制)`，表示协议为TCP。

> 假设客户端有多个网卡，就会有多个IP地址，那IP头部的源地址应该选择哪个IP呢?

当存在多个网卡时，填写源地址IP需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪块网卡来发送包。

这个时候就需要根据路由表规则，来判断哪块网卡作为源地址IP。

linux系统中，可以使用`route -n`命令查看当前系统的路由表。

![15](\imgs\15.png)

举个例子，根据上面的路由表，我们假设web服务器的目标地址是`192.168.10.200`：

![路由规则判断](\imgs\16.jpg)

1. 首先先和第一条目的子网掩码（Genmask）进行`与运算`，得到结果为 `192.168.10.0`，但是第一个条目的 `Destination` 是 `192.168.3.0`，两者不一致所以匹配失败。
2. 再与第二条目的子网掩码进行 **与运算**，得到的结果为 `192.168.10.0`，与第二条目的 `Destination 192.168.10.0` 匹配成功，所以将使用 `eth1` 网卡的 IP 地址作为 IP 包头的源地址。

假设 Web 服务器的目标地址是 `10.100.20.100`，依然依照上面的路由表规则判断，判断后的结果是和第三条目匹配。

第三条目比较特殊，它的目标地址和子网掩码都是 `0.0.0.0`，表示`默认网关`，如果其他所有条目都无法匹配，就会自动匹配这一行，并且后续就把包发给路由器，`Gateway` 即是路由器的 IP 地址。

> IP报文生成

至此，网络包的报文如下图：

![![IP 层报文](\imgs\17.jpg)

> 此时，加上了 IP 头部的数据包表示 ：“有 IP 大佬给我指路了，感谢 IP 层给我加上了 IP 包头，让我有了远程定位的能力！不会害怕在浩瀚的互联网迷茫了！可是目的地好远啊，我下一站应该去哪呢？”

### 2.6 两点传输——MAC

生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 `MAC 头部`。

> MAC包头格式

MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。

![MAC 包头格式](\imgs\18.jpg)

在 MAC 包头里需要`发送方 MAC 地址`和`接收方目标 MAC 地址`，用于`两点之间的传输`。

一般在 TCP/IP 通信里，MAC 包头的`协议类型`只使用：

- `0800` ： IP 协议
- `0806` ： ARP 协议

> MAC 发送方和接收方如何确认?

`发送方`的 MAC 地址获取就比较简单了，MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。

`接收方`的 MAC 地址就有点复杂了，只要告诉以太网对方的 MAC 的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的 MAC 地址。

所以先得搞清楚应该把包发给谁，这个只要查一下`路由表`就知道了。在路由表中找到相匹配的条目，然后把包发给 `Gateway` 列中的 IP 地址就可以了。

> 既然知道要发给谁，按如何获取对方的 MAC 地址呢？

不知道对方 MAC 地址？不知道就喊呗。

此时就需要 `ARP` 协议帮我们找到路由器的 MAC 地址。

![ARP 广播](\imgs\19.jpg)

ARP 协议会在以太网中以`广播`的形式，对以太网所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。

然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。

如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。然后，我们将这个 MAC 地址写入 MAC 头部，MAC 头部就完成了。

> 好像每次都要广播获取，这不是很麻烦吗？

非也。后续操作系统会把本次查询结果放到一块叫做 **ARP 缓存**的内存空间留着以后用，不过缓存的时间就几分钟。

也就是说，在发包时：

- 先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。
- 而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。

> 查看 ARP 缓存内容

 Linux 中可以使用 `arp -a` 命令来查看 ARP 缓存的内容：

![ARP 缓存内容](\imgs\20.jpg)

> MAC 报文生成

至此，网络包的报文如下图：

![MAC 层报文](\imgs\21.jpg)

> 此时，加上了 MAC 头部的数据包万分感谢，说道 ：“感谢 MAC 大佬，我知道我下一步要去哪了！我现在有很多头部兄弟，相信我可以到达最终的目的地！”。 带着众多头部兄弟的数据包，终于准备要出门了。

### 2.7 出口——网卡

网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将`数字信息`转换为`电信号`，才能在网线上传输，也就是说，这才是真正的数据发送过程。

负责执行这一操作的是`网卡`，要控制网卡还需要靠`网卡驱动程序`。

网卡驱动获取网络包之后，会将其`复制`到网卡内的`缓存区`中，接着会在其`开头`加上`报头`和`起始帧分界符`，在`末尾`加上用于检测错误的`帧校验序列`。

![数据包](\imgs\数据包.png)

- 起始帧分界符是一个用来表示包起始位置的标记
- 末尾的 `FCS`（帧校验序列）用来检查包传输过程是否有损坏

最后网卡会将包转为电信号，通过网线发送出去。

> 唉，真是不容易，发一个包，真是历经千辛万苦。致此，一个带有许多头部的数据终于踏上寻找目的地的征途了！

### 2.8 送别者——交换机

下面来看一下包是如何通过交换机的。交换机的设计是将网络包`原样`转发到目的地。交换机工作在 MAC 层，也称为`二层网络设备`。

> 交换机的包接收操作

首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。

然后通过包末尾的 `FCS` 校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。

计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，`交换机的端口不具有 MAC 地址`。

将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。

交换机的 MAC 地址表主要包含两个信息：

- 一个是设备的 MAC 地址，
- 另一个是该设备连接在交换机的哪个端口上。

![交换机的 MAC 地址表](\imgs\23.jpg)

举个例子，如果收到的包的接收方 MAC 地址为 `00-02-B3-1C-9C-F9`，则与图中表中的第 3 行匹配，根据端口列的信息，可知这个地址位于 `3` 号端口上，然后就可以通过交换电路将包发送到相应的端口了。

所以，`交换机根据 MAC 地址表查找 端口列，然后将信号发送到相应的端口`。

> 当 MAC 地址表找不到指定的 MAC 地址会怎么样？

地址表中找不到指定的 MAC 地址。这可能是因为：

1. 具有该地址的设备还没有向交换机发送过包；
2. 这个设备一段时间没有工作导致地址被从地址表中删除了。

这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。

`这样做不会产生什么问题`。因为以太网的设计本来就是将包发送到整个网络的，然后`只有相应的接收者才接收包，而其他设备则会忽略这个包`。

有人会说：“这样做会发送多余的包，会不会造成网络拥塞呢？”

其实完全不用过于担心，因为发送了包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入 MAC 地址表，下次也就不需要把包发到所有端口了。

局域网中每秒可以传输上千个包，多出一两个包并无大碍。

此外，如果接收方 MAC 地址是一个`广播地址`，那么交换机会将包发送到除源端口之外的所有端口。

以下两个属于广播地址：

- MAC 地址中的 `FF:FF:FF:FF:FF:FF`
- IP 地址中的 `255.255.255.255`

> 数据包通过交换机转发抵达了路由器，准备要离开土生土长的子网了。此时，数据包和交换机离别时说道：“感谢交换机兄弟，帮我转发到出境的大门，我要出远门啦！”

### 2.9 出境大门——路由器

> 路由器与交换机的区别

网络包经过交换机之后，现在到达了`路由器`，并在此被转发到下一个路由器或目标设备。

这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。

不过在具体的操作过程上，路由器和交换机是有区别的。

- 因为`路由器是基于 IP 设计的`，俗称`三层网络设备`，路由器的各个端口都具有 MAC 地址和 IP 地址；
- 而`交换机是基于以太网设计的`，俗称`二层网络设备`，交换机的端口不具有 MAC 地址。

> 路由器基本原理

`路由器的端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方；同时还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的`。

当转发包时，首先路由器端口会接收发给自己的以太网包，然后`路由表`查询转发目标，再由相应的端口作为发送方将以太网包发送出去。

> 路由器的包接收操作

首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 `FCS` 进行错误校验。

如果没问题则检查 MAC 头部中的`接收方 MAC 地址`，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。

总的来说，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。

> 查询路由表确定输出端口

完成包接收操作之后，路由器就会`去掉`包开头的 MAC 头部。

`MAC 头部的作用就是将包送达路由器`，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会被丢弃。

接下来，路由器会根据 MAC 头部后方的 `IP` 头部中的内容进行包的转发操作。

转发操作分为几个阶段，首先是查询`路由表`判断转发目标。

![路由器转发](\imgs\24.jpg)

具体的工作流程根据上图，举个例子。

假设地址为 `10.10.1.101` 的计算机要向地址为 `192.168.1.100` 的服务器发送一个包，这个包先到达图中的路由器。

判断转发目标的第一步，就是根据包的接收方 IP 地址查询路由表中的目标地址栏，以找到相匹配的记录。

路由匹配和前面讲的一样，每个条目的子网掩码和 `192.168.1.100` IP 做 `& 与运算`后，得到的结果与对应条目的目标地址进行匹配，如果匹配就会作为候选转发目标，如果不匹配就继续与下个条目进行路由匹配。

如第二条目的子网掩码 `255.255.255.0` 与 `192.168.1.100` IP 做 `& 与运算`后，得到结果是 `192.168.1.0` ，这与第二条目的目标地址 `192.168.1.0` 匹配，该第二条目记录就会被作为转发目标。

实在找不到匹配路由时，就会选择`默认路由`，路由表中子网掩码为 `0.0.0.0` 的记录表示「默认路由」。

> 路由器的发送操作

接下来就会进入包的`发送操作`。

首先，我们需要根据`路由表的网关列`判断对方的地址。

- 如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，`还未抵达终点`，还需继续需要路由器转发。
- 如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明`已抵达终点`。

知道对方的 IP 地址之后，接下来需要通过 `ARP` 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。

路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。

接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 `0800` （十六进制）表示 IP 协议。

网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。

发送出去的网络包会通过`交换机`到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。

接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。

不知你发现了没有，在网络包传输的过程中，`源 IP `和`目标 IP` 始终是不会变的，一直变化的是 MAC 地址，`因为需要 MAC 地址在以太网内进行两个设备之间的包传输`。

> 数据包通过多个路由器道友的帮助，在网络世界途经了很多路程，最终抵达了目的地的城门！城门值守的路由器，发现了这个小兄弟数据包原来是找城内的人，于是它就将数据包送进了城内，再经由城内的交换机帮助下，最终转发到了目的地了。数据包感慨万千的说道：“多谢这一路上，各路大侠的相助！”

### 2.10 互相扒皮——服务器与客户端

数据包抵达了服务器，服务器肯定高兴呀，正所谓有朋自远方来，不亦乐乎？

服务器高兴的不得了，于是开始扒数据包的皮！就好像你收到快递，能不兴奋吗？

![网络分层模型](\imgs\25.jpg)

数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。

接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。

于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP 头部里面还有端口号， HTTP 的服务器正在监听这个端口号。

于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。

服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。

HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。

穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。

最后跳到了客户端的城门把守的路由器，路由器扒开 IP 头部发现是要找城内的人，于是又把包发给了城内的交换机，再由交换机转发到客户端。

客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！

于是，客户端开始扒皮，把收到的数据包的皮扒剩 HTTP 响应报文后，交给浏览器去渲染页面，一份特别的数据包快递，就这样显示出来了！

最后，客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。

### 2.11 Q&A

> 笔记本的是自带交换机的吗?交换机现在我还不知道是什么?

笔记本不是交换机，交换机通常是2个网口以上。

现在家里的路由器其实有了交换机的功能了。交换机可以简单理解成一个设备，三台电脑网线接到这个设备，这三台电脑就可以互相通信了，交换机嘛，交换数据这么理解就可以。

> 我弄不清楚路由器和交换机有什么区别，可以跟我解释一下吗？

当涉及到网络设备时，路由器和交换机都是常见的组件，它们都是用于连接计算机和其他设备的网络设备，但是它们的功能和用途不同。

路由器是一种网络设备，它用于将两个或多个不同网络连接在一起，以便它们可以相互通信。路由器具有路由功能，它可以将来自一个网络的数据包转发到另一个网络。当你连接到互联网时，你的路由器会将你的数据包发送到互联网上的其他设备，使你可以访问互联网上的其他计算机和服务。路由器还可以提供网络安全功能，如防火墙、端口转发和VPN等。

另一方面，交换机是一种网络设备，它用于在同一网络中连接多个设备，如计算机、服务器、打印机等。交换机具有交换功能，它可以在不同设备之间传输数据包。当你在局域网中发送数据时，数据包会通过交换机直接发送到目标设备，而不需要经过路由器。交换机可以提高网络性能和速度，因为它可以直接将数据包传输到目标设备，而不是像路由器那样需要将数据包发送到另一个网络。

总的来说，路由器和交换机都是网络设备，但是它们的功能和用途不同。路由器用于连接不同的网络，而交换机用于连接同一网络中的多个设备。

> 如果知道你电脑的 Mac 地址，我可以直接给你发消息吗?

不可以直接给另外一台电脑发送消息，只知道MAC地址并不足以建立通信。MAC地址是一个用于识别网络设备的唯一标识符，但是它只在局域网内有用(两个设备之间传递使用)。要建立通信，你需要知道另一台电脑的IP地址，以及使用适当的通信协议和应用程序来发送和接收消息。

如果你知道另一台电脑的IP地址，你可以使用网络聊天应用程序或邮件客户端等工具来发送消息。但请注意，发送未经请求的消息或骚扰信息是不被允许的，可能会违反法律法规或网络服务提供商的使用条款。

> 公网服务器的 Mac 地址是在什么时机通过什么方式获取到的?我看 ARP 获取 Mac 地址只能获取到内网机器的 Mac 地址吧?

在发送数据包时，如果目标主机不是本地局域网，填入的 MAC 地址是路由器，也就是把数据包转发给路由器，路由器一直转发下一个路由器，直到转发到目标主机的路由器，发现目标 IP 地址是自己局域网内的主机，就会 ARP 请求获取目标主机的 MAC 地址，从而转发到这个服务器主机。

转发的过程中，源 IP 地址和目标 IP 地址是不会变的（前提：没有使用 NAT 网络的），源 MAC 地址和目标 MAC 地址是会变化的。

## 3.linux系统是如何收发网络包的？

