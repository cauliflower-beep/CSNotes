---
title: 死锁

---

## 1、死锁的概念

当多个进程因竞争系统资源或互相通信而处于永久阻塞状态时，若无外力作用，这些进程都将无法向前推进。其中每一个进程都无限期地等待其他进程释放资源，这种状态被称为**死锁**。

## 2、死锁产生的原因和必要条件

### 2.1、资源分类

系统资源可以分为：

+ 可剥夺资源：虽然资源占有者进程需要使用该资源，但一个进程可以强行该资源从占有的进程剥夺。
+ 不可剥夺资源：除占有者进程不再需要使用该资源而主动释放资源，其他进程不得在占有者使用资源的过程中强行剥夺。

一个资源是否属于可剥夺资源，完全取决于**资源本身的性质**。

### 2.2、死锁产生的原因

竞争资源可能导致死锁了，但竞争资源并不等于死锁。

系统资源不足是产生死锁的根本原因，而进程推进顺序不当是产生死锁的重要原因。

### 2.3、死锁产生的必要条件

+ 互斥条件
+ 不可剥夺
+ 请求与保持（部分分配条件）：每次申请部分资源，且在申请的同时保持已有资源
+ 环路等待：存在一种进程资源的循环等待链

四个必要条件缺一不可！

## 3、处理死锁的基本方法

+ **鸵鸟算法**：就是不管死锁
+ **预防死锁**：设置某些限制条件去破坏产生死锁的 4 个必要条件中的一个或几个。
+ **避免死锁**：在资源动态分配的过程中，用某种方法防止系统进入不安全状态。
+ **监测及解除死锁**

死锁预防和死锁避免有什么不同？

死锁预防是添加严格的限制条件破坏死锁放生的条件，对系统并发性有很大的副作用。

死锁避免是通过算法计算，避免资源分配让系统处于不安全状态，对限制条件不严格。系统并发性更好。

## 4、死锁的预防

1. 互斥条件

   这会受到资源本身固有属性的限制，不能改变。

2. 不可剥夺

   对于已经获得某些资源的进程，新的资源请求不能立即被满足，则必须释放所有已经获得的资源。

   但是这样重复申请会增加系统开销，降低系统吞吐量。

3. 请求保持

   采用预先静态分配方法，要求进程在运行之前一次性申请所有所需的资源，在资源未满足之前，不投入运行。

   这种方法必须实现直到该进程所需的全部资源！

4. 环路等待

   采用有序资源分配法，将系统中的所有资源都按类型赋予一个编号，要求每一个进程均严格按编号递增顺序请求资源，同类资源一次请求完。

   这种方法中各自资源的编号不易修改，限制了新设备的加入；也会增加程序编写的复杂性；不同作业队对资源使用的顺序不同，会造成资源浪费。

## 5、死锁的避免

### 5.1、安全状态与不安全状态

若在某一时刻，系统能按某种顺序来为每一个进程分配其所需的资源，使每个进程都可顺利完成，则称此时系统状态为**安全状态**，该序列为**安全序列**。若某一时刻不存在这样一个安全序列，则系统状态为**不安全状态**。

在某一时刻可以存在多种安全序列！

并非所有不安全状态就是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态。

对系统进行安全性检查是根据进程的最大资源需求而定的，而实际运行过程中进程可能不需要这么多的资源。

### 5.2 银行家算法

这个概念一般考选择题的计算问题，所以没什么概念性的东西，最好根据具体例题理解计算过程，很简单，就是一个加减法的问题。这里就不列出晦涩的描述语言了！

## 6、死锁的检测和解除

### 6.1 死锁的检测

#### 6.1.1、系统资源分配图

进程的死锁问题可以用有向图更准确而形象地描述，这种有向图被称为系统资源分配图（SRAG）。

在 SRAG 中，用圆圈代表进程，用方框代表资源，从进程到资源的有向边是申请边，表示进程申请一个资源，从资源到进程的有向边是分配边，表示有一个资源分配了进程 。

![](https://picbed.kimyang.cn/202108240034150.jpg)

#### 6.1.2、系统资源分配图的简化方法

+ 在 SRAG 中找出一个既不阻塞又非孤立的进程节点 P （从进程集合中找到一个存在链接的边，且资源申请数量小于系统已有空闲资源数量的进程），P 进程完成后释放所有资源，消去它所有的申请边和分配边
+ P 释放资源之后，可以唤醒因等待这些资源而阻塞的进程，在执行前一步消去申请边和分配边
+ 若能消去所有的边，则不会产生死锁，若不能消去所有边，则该图称为不可完全简化图。

**不同的简化顺序将得到相同的不可简化图**！

这方法看起来繁琐，但其内核与银行家算法是一样的，上面写的复杂，实际就是一个加加减减的过程。建议结合实际题目理解！

### 6.2、死锁检测算法

发现死锁的原理就是考察某一时刻系统状态是否安全，即是否存在一组可以实现的系统状态，能使所有进程都得到它们所申请的资源而运行结束。和银行家算法几乎一致！

### 6.3、死锁解除

+ 剥夺资源
+ 撤销进程
+ 进程回退：让一个或多个进程回推到足够回避死锁的地步，进程回退时时自愿放弃自愿而不是被剥夺。要求系统保持进程历史信息，设置还原点。

## 7、死锁与饿死

当等待时间给进程推进和响应带来明显影响时，则称此时发生了**进程饥饿**，当饥饿到一定程度，进程所赋予的任务即使完成也不再具有实际意义的时候，该进程称为饿死。

死锁、饥饿与饿死有什么不同？

+ 进程状态上：死锁进程处于等待状态（阻塞状态）；而饥饿进程处于就绪状态，但却可能被饿死。
+ 死锁进程等待的是永远不会被释放的资源，而饥饿进程等待的是会被释放但不会分配到自己的资源，表现为等待时间没有上限！
+ 死锁一定发生了循环等待，而饿死却不是了。所以资源分配图可以检测死锁，无法检测饿死
+ 死锁一定涉及多个进程，饥饿或饿死可能只有一个！

