---
title: 内存管理基础
---
## 1、内存管理概述

### 1.1、内存管理的功能

+ 内存的分配与回收
+ 地址变换（逻辑地址$\leftrightarrow$物理地址）
+ 扩充内存
+ 存储保护

### 1.2、应用程序的编译、链接与装入

#### 1.2.1、程序的链接方式：

+ 静态链接：直接将各个目标模块以及所需库链接为一个完整的可执行程序
+ 装入时链接：装入内存时边装入边链接
+ 运行时链接：运行过程中需要特定模块才进行装入链接

#### 1.2.2、程序的装入方式

+ 绝对装入：编译阶段就确定好了物理地址

+ 可重定位装入（静态重定位）：

  地址变换在装入时一次完成，实现容易，无需增加硬件地址变化机构 。要求为程序分配连续的存储区，若空间不足就不能分配成功，程序执行期间不能移动，不能扩充内存空间，难以做到程序和数据共享。

+ 动态运行装入（动态重定位）：

  在程序执行过程中每当访问到相应指令或数据时，才进行对应指令或数据的地址转换。其实现需要依靠硬件地址变换机构。可以使用不连续的存储区，装入部分代码就可运行，执行期间可以动态申请内存，便于程序共享。

### 1.3、逻辑地址和物理地址

逻辑地址是指由程序产生的与段（与页无关）相关的偏移地址部分

物理地址是指出现在 CPU 外部地址总线上的寻址物理内存的地址信号，是逻辑地址变换后的最终结果地址。

在重定位中通常会设置一个重定位寄存器（基址寄存器），用来存放进程分配的内存空间地址，其转化公式为：物理地址=基址寄存器+逻辑地址

### 1.4、内存保护

为了防止一个作业有意或者无意地破坏操作系统或其他作业。常用内存保护方法有：

+ **界限寄存器方法**

  两种实现方式：

  + **上下界寄存器方法**

    采用上下界寄存器分别存放作业的结束地址和开始地址

  + **基址和限长寄存器方法**

    采用基址和限长寄存器分别存放作业的起始地址以及作业的地址空间长度

+ **存储保护键方法**

  给每个存储块分配一个单独的保护键，作用相当于一把“锁”，进入系统的每个作业也被赋予了一个保护键，它相当于一把“钥匙”，作业运行时，会检查两者是否匹配

## 2、覆盖与交换

### 2.1、覆盖技术

把一个大的程序划分为一系列覆盖，每个覆盖是一个相对独立的程序单位。把程序执行时并不要求同时装入内存的覆盖组成一组，称为覆盖段。将这个覆盖段分配到同一个存储区域，这个存储区域被称为覆盖区，它与覆盖段一一对应。覆盖区的大小由与之对应的覆盖段中最大覆盖确定。

覆盖技术打破了必须将一个进程的全部信息装入主存后才能运行的限制。但当同时执行程序的代码量超过主存时，程序仍然不能运行。

### 2.2、交换技术

把暂时不用的某个程序及数据部分从内存移到外存中，以便腾出必要的内存空间；或把指定的程序或数据从外存读到相应的内存中，并将控制权转让给它，让其在系统上运行的一种内存扩充技术。处理器三级调度中的中级调度就是采用了交换技术。

交换基础打破了一个程序一旦进入主存便一致运行到结束的限制。但运行的进程大小仍然受实际主存的限制。

## 3、连续分配管理方式

**什么是内部碎片与外部碎片**？

+ 内部碎片是指已经分配给作业但不能被利用的内存空间，
+ 外部碎片是指系统中还没有分配给作业，但由于碎片太小二无法分配给申请内存空间的新进程的存储块

### 3.1、单一连续分配

将内存分为两个连续存储区域，其一固定分配给操作系统使用（低地址部分），另一留给用户作业使用。采用**静态分配**，适合单道程序，可采用覆盖技术。

优点：管理简单，只需要很少的软件和硬件支持，便于用户了解和使用，不存在其他用户干扰的问题

缺点：只能用于单用户，单任务的操作系统，内存中只装入一道作业运行，从而导致各类资源利用率都很低

### 3.2、固定分区分配

将内存空间划分为若干个固定大小的分区，每个分区中可以装入一道程序，分区大小可以不等，但实现必须确定，在运行时不可改变，程序通常采用**静态重定位**方式装入内存。实现时，需要一张分区说明表，以记录用户分配的分区号，分区的大小，分区的起始地址以及状态。分区大小可相等，也可不等。

优点：可用于**多道程序系统**的最简单的存储分配。

缺点：不能实现多进程共享一个主存区，利用率低，会产生**内部碎片**。

### 3.3、动态分区分配

不事先将主存划分成一块块的分区，而是在作业进入内存时，根据作业的大小动态地建立分区，并使分区的大小正好满足作业的需要。因此分区大小可变，分区数目也可变。

#### 3.3.1、动态分配的数据结构

+ **空闲分区表**：登记系统的中的空闲分区，每个空闲分区对应一个表项，每个表项包含分区号、起始地址、大小以及状态。
+ **空闲分区链**：用链头指针将内存中的空闲分区链接起来，构成空闲分区链。

#### 3.3.2、动态分配的分配算法

+ **首次适应算法（First Fit，FF）**

  把空闲分区按照**地址递增**的次序用链表串成一个队列，每次需要为一个进程分配内存时都从队首开始找，顺着链表直到找到足够大的空闲分区，然后按作业大小从该分区中划分一块内存空间分配，剩余的空闲分区仍然留在空闲分区表中。若从头到尾都不存在符合的分区，即分配失败

  + 优点：优先利用内存低地址部分的空闲分区，从而保留了高地址部分的大的空闲分区
  + 缺点：由于低地址部分不断被划分，导致出现**外部碎片**，而每次查找又是从低地址开始的，会增加查找空闲分区的开销。

+ **下次适应算法（Next Fit，NF）**

  在首次适应算法的基础上把队列改成循环队列，并从上次找到的空闲分区的下一个分区开始查找空闲分区。故又称**循环首次适应算法**

  + 优点：空闲分区分布更加均匀，减少了查找空闲分区的开销
  + 缺点：缺乏大的空闲分区

+ **最佳适应算法（Best Fit，BF）**

  要求将空闲分区按**容量递增**排序，每次为作业分配内存空间时，总是将能满足空间大小的最小空闲分区分配给作业。

  + 优点：作业总能分配到最恰当的分区，并保留最大的分区。
  + 缺点：产生**外部碎片**

+ **最差适应算法（Worst Fit，WF）**

  要求空闲分区按照**容量递减**的次序排列，每次为作业分配内存空间时，总是将满足要求且最大的内存空间分配给作业。

  + 优点：减少了**外部碎片**
  + 缺点：缺乏大的空闲分区，容易导致大作业得不到满足

#### 3.3.3、动态分配的分区回收

根据回收分区的大小以及首地址，在空闲分区表（空闲分区链）中**检查是否有相邻的空闲分区**，若有则合并两者并修改相关分区状态信息。

#### 3.3.4、动态分配的动态管理

对内存中许多小容量分区进行动态管理，使其能够装入小于其总容量但大于每个小分区的作业。实现动态管理的主要技术是分区重定位技术，目前有两种：

+ 拼接技术：将存储器中所有已分配分区移到主存的一端，使所有碎片分区链接成一个大的分区。

  因为拼接的系统开销较大，所以应用拼接时机目前有两种方案：

  + 在某个分区回收时立即进行拼接，这样，内存中总是只有一个连续的空闲分区。但拼接频率过高，导致系统开销加大
  + 当找不到足够大的空闲分区且总容量可以满足作业要求时进行拼接。

+ 动态重定位分区分配技术：

  与**动态分区分配算法**基本相同：在**分配算法**中添加了拼接功能，通常在找不到足够大的空闲分区来满足作业要求，而系统中空闲分区容量总和大于作业要求时进行拼接。

#### 3.3.5、 动态分区分配的优缺点

+ 优点：
  1. 实现了多道程序共用主存（共用是指多进程同时存在于主存中的不同位置）；
  2. 管理方案相对简单，不需要更多开销；
  3. 实现存储保护手段比较简单。
+ 缺点：
  1. 主存利用不够充分，存在**外部碎片**
  2. 无法实现多进程共享存储器信息（共享指多进程都在使用同一个主存段）
  3. 无法实现主存扩充，进程地址空间受实际存储空间的限制

## 4、非连续分配管理方式

非连续分配允许一个程序分散地装入到不相邻的内存分区中。因为需要额外空间存储分散区域的索引，所以**非连续分配方式的存储密度低于连续分配方式**。

非连续分配管理方式根据**分区大小是否固定**分为**分页存储管理方**式和**分段存储管理方式**，其中分页存储管理方式根据**运行作业时是否需要把作业的所有页全部装入内存才能运行**而分为**基本分页存储管理方式**和**请求分页存储管理方式**。

### 4.1、基本分页存储管理方式

#### 4.1.1、分页原理

把用户作业的地址空间划分成若干个大小相等的区域，称为**页（页面）**；相应地把主存的存储空间也划分成**与页面大小相等**的区域，称为**块（物理块）（页框）**，在分配存储空间时，总是以**块**为单位来分配，可以将作业的任意一页放到主存的任意一块中。

页面大小由机器地址结构决定，一般选择适中（通常为 2 的倍数），以方便地址变换，一般为 512~4kb。其逻辑地址包含两部分，前为页号P，后为页内位移W

![image-20210823155407282](https://picbed.kimyang.cn/202108231554217.png)

假设逻辑地址是 A ，页面大小为 L 则页号 P=(int)(A/L)，W=A%L；（int）代表取整

#### 4.1.2、页表

为了将逻辑地址上连续的页号映射到物理内存中后成为离散分布的物理块，需要将每个页面与物理块一一对应，页表就记录了这种映射关系。页表中每个页表项都由**页号**和**块号**组成。页表通常存储在**内存**中。

![image-20210823161327253](https://picbed.kimyang.cn/202108231613328.png)

#### 4.1.3、基本地址变换机构

![1-140F1004005H3](https://picbed.kimyang.cn/202108231757855.jpg)

整个地址变换过程都是由**硬件**自动完成的。

**页表寄存器（PTR）**：用来存放**页表在内存中的起始地址和页表长度**

假设页面大小为 L；页表长度为 M，逻辑地址为 A，物理地址为E，则从逻辑地址 A 转换为物理地址的步骤为：

+ 计算页号 P=（int）A/L；页内位移 W= A%L
+ 比较页号 P 和页表长度 M，若 P>M，则产生越界中断，否则继续
+ 计算 F+ P*页表项长度，用得的值，从内存中取出物理块号 b
+ 用物理块号 b 和物理块大小的乘积，与页内地址 W 组成物理地址 E

由上述过程可知，页表全部存放在内存中时，存取一条数据或指令至少需要访问**两次**内存。

#### 4.1.4、具有快表的地址变换机构

为了提高地址变换的速度，可以在地址变换机构中增加一个具有并行查找功能的高度缓冲存储器（联想存储器/快表），将部分页表项放在快表中。

![1-140F1004005H3](https://picbed.kimyang.cn/202108231758618.jpg)

增加块表之后的地址变换过程：

+ 根据逻辑地址计算页号 P 和页内位移 W
+ 先将页号与块表中的所有页号对比，若有匹配的页号，则直接读出对应块号，与页内位移拼接得到物理地址；若没有匹配的页号，则还需访问内存中的页表，流程和前文一致。

如果直接从块表读出了块号，就只需访问一次内存，如果没有就只能访问内存两次了。

#### 4.1.5、两级页表和多级页表

1. **页表大小=页号数*页表项大小**，其中页号数由页号位数决定

2. 如果页表大小过大，需要占据的连续内存空间就越大，由此产生了**两级页表**。

3. 可以不断通过增加页表的级数来缩小页表的大小，由此产生**多级页表**，但是会导致多次访问内存，增加地址变换的时间开销。

   ![1-140F1005205M0](https://picbed.kimyang.cn/202108231840981.jpg)

#### 4.1.6、页的共享和保护

分页存储管理中，实现共享的方式是**使用户地址空间中的页指向相同的物理块**。

分页存储管理提供两种保护方式：

1. 地址越界保护：比较地址变换机构中的页表长度和所要访问的逻辑地址中的页号
2. 访问控制保护：通过页表中的访问控制信息对内存信息提供保护

#### 4.1.7、基本分页存储管理方式的优缺点

+ 优点：
  1. 内存利用率高
  2. 实现了离散分配
  3. 便于存储访问控制
  4. 无外部碎片
+ 缺点：
  1. 需要硬件支持（尤其是快表）
  2. 内存访问效率下降
  3. 共享困难

### 4.2、基本分段存储管理方式

### 4.2.1、分段存储原理

分段存储管理中，作业的地址空间有若干个逻辑分段组成，每个分段是一组逻辑意义上**相对完整的信息集合**，每个分段都有自己的名字，每个分段都从 0 开始编址，并采用一段连续的地址空间。因此，整个作业的**地址空间是二维的**。分段存储管理中以**段**为基本单位分配内存，**每段分配一个连续内存，但是各段之间不要求连续。**

![1-140F1005Z3T5](https://picbed.kimyang.cn/202108231840536.png)

**为什么分页存储管理系统的作业地址空间是一维的，而分段存储管理系统是二维的？**

1. 注意段号和页号的来历不同，页号是系统自动生成的，本身地址是线性连续的，当访问特定地址时只需要提供**逻辑地址**即可，系统会自动将地址划分为页号和页内地址。而段号是程序员自己定义的，每段的段长都不同，因此想要找到某个数据或指令需要**指定段号和位移**两个变量。
2. 在分页存储管理中，低位页内地址和低位块内地址是完全对应的。照抄即可，仅需进行页号和块号的转换；而分段存储管理的每一段长都不同，所以段内地址的开始地址就是不确定的，需要先确定高位段号的起始地址。

#### 4.2.2、段表及地址变换过程

系统为每个进程建立一个段表，每个表项包含段号，段长和该段内存起始地址等信息。

![1-140F10101563W](https://picbed.kimyang.cn/202108231853766.png)

![image-20210823185548803](https://picbed.kimyang.cn/202108231855897.png)

段表寄存器：存放段表起始地址和段表长度。

#### 4.2.3、段的共享和保护

在分段存储管理中，分段的共享是通过使多个作业的段表相应表项都指向被共享段的同一个物理副本来实现。

与分页相似，分段管理的保护主要有两种：地址越界保护和访问控制保护。

#### 4.2.4、基本分段存储管理方式的优缺点

+ 优点
  1. 便于程序模块化处理和处理交换的数据结构
  2. 便于动态链接和共享
  3. 无内部碎片
+ 缺点：
  1. 需要硬件支持
  2. 为满足分段的动态增长和减少外部碎片，要采用拼接技术
  3. 分段最大尺寸受到主存可用空间的限制
  4. 有外部碎片

#### 4.2.5、 分段和分页区别

|                分页                |                分段                |
| :--------------------------------: | :--------------------------------: |
|           信息的物理单位           |           信息的逻辑单位           |
| 系统管理的需要，为了提供内存利用率 |           满足用户的需要           |
|      页面大小固定且由系统决定      | 段的长度不定，由用户编写的程序决定 |
|        作业地址空间时一维的        |        作业地址空间时二维的        |
|       有内存碎片，无外部碎片       |       无内部碎片，有外部碎片       |

## 4.3、基本段页式存储管理方式

分页系统能有效提供内存利用率并能解决碎片问题，而分段系统能反映程序的逻辑结构并有利于段的共享。将二者结合就形成了段页式存储管理方式。

在段页式存储管理中，作业的地址空间首先被分成了若干个逻辑分段，每段都有自己段号，然后再将每一段分成若干个大小固定的页。将主存空间分成若干个与页面大小相同的物理块，分配时以物理块为基本单位。

逻辑地址结构：

![](https://picbed.kimyang.cn/202108232005389.png)

系统为每个进程建立一张段表，而每个分段都有一张页表。段表表项包括段号、页表始址和页表长度，页表表项包括页号和块号。其地址转换过程如下：

![](https://picbed.kimyang.cn/202108232010269.jpeg)

从上述过程可以看出段页式存储管理的地址变化需要访问内存三次。所以同样可以用块表来减少对内存的访问次数

段页式结合了段式和页式的优点，解决了段式的外部碎片问题，但是增加了页式内部碎片问题。



