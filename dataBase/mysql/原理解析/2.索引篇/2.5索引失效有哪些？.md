如果想提高一条语句查询速度，通常都会想对字段建立索引。但建立索引，并不意味着任何查询语句都能走索引扫描。

稍不注意，可能查询语句会导致索引失效，从而走了全表扫描，虽然查询的结果没问题，但是性能大大降低。

![图片](..\imgs\索引失效概览.png)

## 1.索引存储结构长什么样？

知道索引的存储结构，有助于理解索引失效的问题。

索引的存储结构与存储引擎有关，因为存储引擎负责将数据持久化在磁盘中，不同的存储引擎采用的索引数据结构也不相同。

以 InnoDB 为例，它采用 B+Tree 作为索引的数据结构。

创建表时，InnoDB 存储引擎默认会创建一个主键索引（**聚簇索引**），其它索引都属于二级索引。

MySQL 的 MyISAM 存储引擎支持多种索引数据结构，比如 B+ 树、R 树、Full-Text 。它在创建表时，创建的主键索引默认使用的是 B+ 树索引。

虽然，InnoDB 和 MyISAM 都支持 B+ 树索引，但它们数据的存储结构实现方式不同：

- InnoDB ：B+ 树索引的叶子节点保存数据本身；
- MyISAM ：B+ 树索引的叶子节点保存数据的物理地址；

举例展示这两种存储引擎的索引存储结构的区别。

这里有一张 t_user 表，其中 id 字段为主键索引，其他都是普通字段。

![图片](..\imgs\t_user.png)

如果使用的是 MyISAM 存储引擎，B+ 树索引的叶子节点保存数据的物理地址，即用户数据的指针，如下图：

![图片](..\imgs\MyISAM_B+Tree.png)

如果使用的是 InnoDB 存储引擎， B+ 树索引的叶子节点保存数据本身，如下图所示（叶子节点之间是双向链表，自行脑补）。

![图片](..\imgs\InnoDB_B+Tree.png)

InnoDB 存储引擎根据索引类型不同，分为聚簇索引（上图就是聚簇索引）和二级索引：

- 聚簇索引的叶子节点存放的是实际数据，所有完整的用户数据都存放在聚簇索引的叶子节点；
- 二级索引的叶子节点存放的是主键值，而非实际数据。

如果将 name 字段设置为普通索引，那么这个二级索引长下图这样（叶子节点之间是双向链表，自行脑补），**叶子节点仅存放主键值**。

![图片](https://cdn.xiaolincoding.com//mysql/other/7dd91be9fe584d94a4d71572ae7214d0.png)

查询过程是怎么选择用哪个索引类型的？

使用「主键索引」字段作为条件查询的时候，如果要查询的数据都在「聚簇索引」的叶子节点里，那么就会在「聚簇索引」中的 B+ 树检索到对应的叶子节点，然后直接读取要查询的数据。如下面这条语句：

```sql
-- id 字段为主键索引
select * from t_user where id=1;
```

使用「二级索引」字段作为条件查询的时候，如果要查询的数据都在「聚簇索引」的叶子节点里，那么需要检索两颗B+树：

- 先在「二级索引」的 B+ 树找到对应的叶子节点，获取主键值；
- 利用主键值，在「聚簇索引」中的 B+ 树检索到对应的叶子节点，获取要查询的数据。

上面这个过程叫做**回表**，如下面这条语句：

```sql
-- name 字段为二级索引
select * from t_user where name="林某";
```

使用「二级索引」字段作为条件查询的时候，如果要查询的数据在「二级索引」的叶子节点，那么只需要在「二级索引」的 B+ 树找到对应的叶子节点，然后读取要查询的数据，这个过程叫做**覆盖索引**。如下面这条语句：

```sql
-- name 字段为二级索引
select id from t_user where name="林某";
```

上面这些查询语句的条件都用到了索引列，所以在查询过程都用上了索引。

但并不是查询条件用上了索引列，查询过程就一定都用上索引。某些情况会导致索引失效，而发生全表扫描。

下面的实验案例都是基于 MySQL `8.0.26`版本。

## 2.对索引使用左或者左右模糊匹配

使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%` 会造成索引失效。

比如，查询 name 后缀为「林」的用户，执行计划中的 type=ALL 就代表了全表扫描，没有走索引。

```sql
-- name 字段为二级索引
select * from t_user where name like '%林';
```

![图片](..\imgs\左模糊匹配.png)

如果是查询 name 前缀为林的用户，那么就会走索引扫描，执行计划中的 type=range 表示走索引扫描，key=index_name 看到实际走了 index_name 索引：

```sql
-- name 字段为二级索引
select * from t_user where name like '林%';
```

![图片](..\imgs\右模糊匹配.png)

> 为什么 like 关键字左或者左右模糊匹配无法走索引呢？

**因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。**

举个例子，下面这张二级索引图（叶子节点之间是双向链表，自行脑补），是以 name 字段有序排列存储的。

![图片](..\imgs\二级索引.png)

假设要查询 name 字段前缀为「林」的数据，也就是 `name like '林%'`，扫描索引的过程：

- 首节点查询比较：林这个字的拼音大小比首节点的第一个索引值中的陈字大，但是比首节点的第二个索引值中的周字小，所以选择去节点2继续查询；
- 节点 2 查询比较：节点2的第一个索引值中的陈字的拼音大小比林字小，所以继续看下一个索引值，发现节点2有与林字前缀匹配的索引值，于是就往叶子节点查询，即叶子节点4；
- 节点 4 查询比较：节点4的第一个索引值的前缀符合林字，于是就读取该行数据，接着继续往右匹配，直到匹配不到前缀为林的索引值。

如果使用 `name like '%林'` 方式来查询，因为查询的结果可能是「陈林、张林、周林」等之类的，所以不知道从哪个索引值开始比较，于是就只能通过全表扫描的方式来查询。

## 3.对索引使用函数

有些 sql 会包含一些 MySQL 自带的函数，如果查询条件中对索引字段使用函数，会导致索引失效。

如下这条语句查询条件中对 name 字段使用了 LENGTH 函数，执行计划中的 type=ALL，代表了全表扫描：

```sql
-- name 为二级索引
select * from t_user where length(name)=6;
```

![图片](..\imgs\对索引使用函数.png)

> 为什么对索引使用函数，就无法走索引了呢？

索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。

不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。

举个例子，通过下面这条语句，对 length(name) 的计算结果建立一个名为 idx_name_length 的索引。

```sql
alter table t_user add key idx_name_length ((length(name)));
```

然后我再用下面这条查询语句，这时候就会走索引了。

![图片](..\imgs\为函数值建立索引.png)

## 4.对索引进行表达式计算

在查询条件中对索引进行表达式计算，也是无法走索引的。

比如，下面这条查询语句，执行计划中 type = ALL，说明是通过全表扫描的方式查询数据的：

```sql
explain select * from t_user where id + 1 = 10;
```

![图片](..\imgs\对索引进行表达式计算.png)

但是，如果把查询语句的条件改成 where id = 10 - 1，这样就不是在索引字段进行表达式计算了，于是就可以走索引查询了。

![图片](..\imgs\对索引进行算数运算.png)

> 为什么对索引进行表达式计算，就无法走索引了呢？

原因跟对索引使用函数差不多。

索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。

有的同学可能会说，这种对索引进行简单的表达式计算，在代码特殊处理下，应该是可以做到索引扫描的，比方将 id + 1 = 10 变成 id = 10 - 1。

是的，是能够实现，但是 MySQL 还是偷了这个懒，没有实现。

可能是因为，表达式计算的情况多种多样，每种都要考虑的话，代码可能会很臃肿，干脆将这种索引失效的场景告诉程序员，让程序员自己保证在查询条件中不要对索引进行表达式计算。

## 5.对索引隐式类型转换

如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，会在执行计划的结果发现这条语句会走全表扫描。

 t_user 表增加 phone 字段，是二级索引且类型是 varchar。

![图片](..\imgs\t_user_phone.png)

条件查询中，用整型作为输入参数，此时执行计划中 type = ALL，所以是通过全表扫描来查询数据的。

```sql
select * from t_user where phone = 1300000001;
```

![图片](..\imgs\索引-隐式类型转换.png)

但是如果索引字段是整型类型，查询条件中的输入参数即使字符串，是不会导致索引失效，还是可以走索引扫描。

再看第二个例子，id 是整型，但是下面这条语句还是走了索引扫描的。

```sql
 explain select * from t_user where id = '1';
```

![图片](..\imgs\字符串转int.png)

> 为什么第一个例子会导致索引失效，而第二例子不会呢？

要明白这个原因，首先要知道 MySQL 的数据类型转换规则。就是看 MySQL 是会将字符串转成数字处理，还是将数字转换成字符串处理。

有一个简单的测试方式，通过 select “10” > 9 的结果来知道MySQL 的数据类型转换规则是什么：

- 如果规则是 MySQL 会将自动「字符串」转换成「数字」，就相当于 select 10 > 9，这个就是数字比较，所以结果应该是 1；
- 如果规则是 MySQL 会将自动「数字」转换成「字符串」，就相当于 select "10" > "9"，这个是字符串比较，字符串比较大小是逐位从高位到低位逐个比较（按ascii码） ，那么"10"字符串相当于 “1”和“0”字符的组合，所以先是拿 “1” 字符和 “9” 字符比较，因为 “1” 字符比 “9” 字符小，所以结果应该是 0。

![图片](..\imgs\10大于9.png)

上面的结果为 1，说明 **MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较**。

回看这个查询语句：

```sql
select * from t_user where phone = 1300000001;
```

因为 phone 字段为字符串，所以 MySQL 要会自动把字符串转为数字，所以这条语句相当于：

```sql
select * from t_user where CAST(phone AS signed int) = 1300000001;
```

可以看到，**CAST 函数是作用在了 phone 字段，而 phone 字段是索引，也就是对索引使用了函数！对索引使用函数是会导致索引失效的**。

而这个查询语句：

```sql
select * from t_user where id = "1";
```

因为字符串部分是输入参数，也就需要将字符串转为数字，所以这条语句相当于：

```sql
select * from t_user where id = CAST("1" AS signed int);
```

可以看到，索引字段并没有用任何函数，CAST 函数是用在了输入参数，因此是可以走索引扫描的。

## 6.联合索引非最左匹配

对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。

**多个普通字段组合在一起创建的索引叫做联合索引**，也叫组合索引。

创建联合索引时，需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。

联合索引要能正确使用需要遵循**最左匹配原则**，也就是按照最左优先的方式进行索引的匹配。

比如，如果创建了一个 `(a, b, c)` 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：

- where a=1；
- where a=1 and b=2 and c=3；
- where a=1 and b=2；

需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。

但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:

- where b=2；
- where c=3；
- where b=2 and c=3；

有一个比较特殊的查询条件：where a = 1 and c = 3 ，符合最左匹配吗？

这种其实严格意义上来说是属于索引截断，不同版本处理方式也不一样。

MySQL 5.5 的话，前面 a 会走索引，在联合索引找到主键值后，开始回表，到主键索引读取数据行，Server 层从存储引擎层获取到数据行后，然后在 Server 层再比对 c 字段的值。

从 MySQL 5.6 之后，有一个**索引下推功能**，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。

索引下推的大概原理是：截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 c 字段的值是在 `(a, b, c)` 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。

比如下面这条 where a = 1 and c = 0 语句，我们可以从执行计划中的 Extra=Using index condition 使用了索引下推功能。

![图片](..\imgs\索引下推.png)

> 为什么联合索引不遵循最左匹配原则就会失效？

原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。

也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引。

## 7.WHERE 子句中的 OR

在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

举个例子，比如下面的查询语句，id 是主键，age 是普通列，从执行计划的结果看，是走了全表扫描。

```sql
select * from t_user where id = 1 or age = 18;
```

![图片](..\imgs\where中的or.png)

这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。

要解决办法很简单，将 age 字段设置为索引即可。

![图片](..\imgs\or字段都创建索引.png)

可以看到 type=index merge， index merge 的意思就是对 id 和 age 分别进行了扫描，然后将这两个结果集进行了合并，这样做的好处就是避免了全表扫描。

## 8.MySQL 使用 like “%x“，索引一定会失效吗？

题目一：一个表有多个字段，其中name是索引字段，其他非索引，id拥有自增主键索引。

题目二：一个表有两个字段，其中name是索引字段，id拥有自增主键索引。

上面两张表，分别执行如下查询语句：

- select * from s where name like "xxx";
- select * from s where name like "xxx%";
- select * from s where name like "%xxx";
- select * from s where name like "%xxx%";

针对题目1和题目2的数据表，哪些触发索引查询，哪些没有？

### 8.1题目一

数据库表如下，id 是主键索引，name 是二级索引，其他字段都是非索引字段。

![图片](..\imgs\t1.png)

这四条模糊匹配的查询语句，第一条和第二条都会走索引扫描，而且都是选择扫描二级索引（index_name），第二条查询语句的执行计划结果图：

![图片](..\imgs\s1s2执行计划.png)

而第三和第四条会发生索引失效，执行计划的结果 type= ALL，代表了全表扫描。

![图片](..\imgs\s3s4执行计划.png)

### 8.2题目二

题目 2 的数据库表特别之处在于，只有两个字段，一个是主键索引 id，另外一个是二级索引 name。

![图片](..\imgs\t2.png)

针对题目 2 的数据表，第一条和第二条模糊查询语句也是一样可以走索引扫描，第二条查询语句的执行计划如下，Extra 里的 Using index 说明用上了覆盖索引：

![图片](..\imgs\s1s2执行计划2.png)

我们来看一下第三条查询语句的执行计划（第四条也是一样的结果）：

![图片](..\imgs\s3s4执行计划2.png)

从执行计划的结果中，可以看到 key=index_name，也就是说用上了二级索引，而且从 Extra 里的 Using index 说明用上了覆盖索引。

为什么？

首先，这张表的字段没有「非索引」字段，所以 `select *` 相当于 `select id,name`，然后**这个查询的数据都在二级索引的 B+ 树，因为二级索引的 B+ 树的叶子节点包含「索引值+主键值」，所以查二级索引的 B+ 树就能查到全部结果了，这个就是覆盖索引。**

但是执行计划里的 type 是 `index`，这代表着是通过全扫描二级索引的 B+ 树的方式查询到数据的，也就是遍历了整颗索引树。

而第一和第二条查询语句的执行计划中 type 是 `range`，表示对索引列进行范围查询，也就是利用了索引树的有序性的特点，通过查询比较的方式，快速定位到了数据行。

所以，type=range 的查询效率会比 type=index 的高一些。

> 为什么选择全扫描二级索引树，而不扫描聚簇索引树呢？

因为二级索引树的记录东西很少，就只有「索引列+主键值」，而聚簇索引记录的东西会更多，比如聚簇索引中的叶子节点则记录了主键值、事务 id、用于事务和 MVCC 的回滚指针以及所有的剩余列。

再加上，这个 select * 不用执行回表操作。

所以， MySQL 优化器认为直接遍历二级索引树要比遍历聚簇索引树的成本要小的多，因此 MySQL 选择了「全扫描二级索引树」的方式查询数据。

> 为什么这个数据表加了非索引字段，执行同样的查询语句后，怎么变成走的是全表扫描呢？

加了其他字段后，`select * from t_user where name like "%xx";` 要查询的数据就不能只在二级索引树里找了，得需要回表操作才能完成查询的工作，再加上是左模糊匹配，无法利用索引树的有序性来快速定位数据，所以得在二级索引树逐一遍历，获取主键值后，再到聚簇索引树检索到对应的数据行，这样实在太累了。

所以，优化器认为上面这样的查询过程的成本实在太高了，所以直接选择全表扫描的方式来查询数据。

### 8.3分析

从这个思考题我们知道了，使用左模糊匹配（like "%xx"）并不一定会走全表扫描，关键还是看数据表中的字段。

如果数据库表中的字段只有主键+二级索引，那么即使使用了左模糊匹配，也不会走全表扫描（type=all），而是走全扫描二级索引树(type=index)。

再说一个类似的情况：联合索引要遵循最左匹配才能走索引，但是如果数据库表中的字段都是索引的话，即使查询过程中，没有遵循最左匹配原则，也是走全扫描二级索引树(type=index)，比如下图：

![图片](..\imgs\全字段索引.png)

## 总结

 6 种会发生索引失效的情况：

- 使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效；
- 在查询条件中对索引列使用函数，会导致索引失效。
- 在查询条件中对索引列进行表达式计算，也是无法走索引的。
- MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。
- 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
- 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。